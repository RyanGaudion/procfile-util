#!/bin/sh
# Init script for {{ .app }}-{{ .process_type }}-{{ .num }}
# Maintained by {{ if .author }}{{ .author }}{{ end }}
# Generated by pleaserun.
# Implemented based on LSB Core 3.1:
#   * Sections: 20.2, 20.3
#
### BEGIN INIT INFO
# Provides:          {{ .app }}-{{ .process_type }}-{{ .num }}
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: {{ if .one_line_description }}{{ .one_line_description }}{{ end }}
# Description:       {{ .description }}
### END INIT INFO

PATH=/sbin:/usr/sbin:/bin:/usr/bin
export PATH

name={{ .app }}-{{ .process_type }}-{{ .num }}
program={{ .program}}
args={{ .args_escaped }}
pidfile="/var/run/$name.pid"
user="{{ .user }}"
group="{{ .group }}"
chroot="{{ .working_directory }}"
chdir="{{ .working_directory }}"
nice="{{ .nice}}"
{{- if .limit_coredump }}
limit_coredump="{{ .limit_coredump }}"{{ end }}
{{- if .limit_cputime }}
limit_cputime="{{ .limit_cputime }}"{{ end }}
{{- if .limit_data }}
limit_data="{{ .limit_data }}"{{ end }}
{{- if .limit_file_size }}
limit_file_size="{{ .limit_file_size }}"{{ end }}
{{- if .limit_locked_memory }}
limit_locked_memory="{{ .limit_locked_memory }}"{{ end }}
{{- if .limit_open_files }}
limit_open_files="{{ .limit_open_files }}"{{ end }}
{{- if .limit_user_processes }}
limit_user_processes="{{ .limit_user_processes }}"{{ end }}
{{- if .limit_physical_memory }}
limit_physical_memory="{{ .limit_physical_memory }}"{{ end }}
{{- if .limit_stack_size }}
limit_stack_size="{{ .limit_stack_size }}"{{ end }}

# If this is set to 1, then when `stop` is called, if the process has
# not exited within a reasonable time, SIGKILL will be sent next.
# The default behavior is to simply log a message "program stop failed; still running"
KILL_ON_STOP_TIMEOUT=0

# When loading default and sysconfig files, we use `set -a` to make
# all variables automatically into environment variables.
set -a
[ -r /etc/default/{{ .app  }} ] && . /etc/default/{{ .app  }}
[ -r /etc/sysconfig/{{ .app }} ] && . /etc/sysconfig/{{ .app }}
set +a
export PORT={{ .port }}
export PS={{ .ps }}

[ -z "$nice" ] && nice=0

trace() {
  logger -t "/etc/init.d/{{ .app }}-{{ .process_type }}-{{ .num }}" "$@"
}

emit() {
  trace "$@"
  echo "$@"
}

start() {
  {{/* I do not use 'su' here to run as a different user because the process 'su'
      stays as the parent, causing our pidfile to contain the pid of 'su' not the
      program we intended to run. Luckily, the 'chroot' program on OSX, FreeBSD, and Linux
      all support switching users and it invokes execve immediately after chrooting. */}}

  # Ensure the log directory is setup correctly.
  if [ ! -d "{{ .log  }}" ]; then 
    mkdir "{{ .log  }}"
    chown "$user":"$group" "{{ .log  }}"
    chmod 755 "{{ .log  }}"
  fi

  {{- if .prestart }}
  if [ "$PRESTART" != "no" ] ; then
    # If prestart fails, abort start.
    prestart || return $?
  fi
  {{ end }}

  # Setup any environmental stuff beforehand
  {{ if .ulimit_shell }}{{ .ulimit_shell }}{{ end }}

  # Run the program!
  {{- if .nice }}nice -n "$nice"{{ end }}
  chroot --userspec "$user":"$group" "$chroot" sh -c "
    {{ if .ulimit_shell }}{{ .ulimit_shell }}{{ end }}
    cd \"$chdir\"
    exec \"$program\" $args
  " >> {{ .log }}/{{ .app }}-{{ .process_type }}-{{ .num }}-stdout.log 2>> {{ .log }}/{{ .app }}-{{ .process_type }}-{{ .num }}-stderr.log &

  # Generate the pidfile from here. If we instead made the forked process
  # generate it there will be a race condition between the pidfile writing
  # and a process possibly asking for status.
  echo $! > $pidfile

  emit "$name started"
  return 0
}

stop() {
  # Try a few times to kill TERM the program
  if status ; then
    pid=$(cat "$pidfile")
    trace "Killing $name (pid $pid) with SIGTERM"
    kill -TERM $pid
    # Wait for it to exit.
    for i in 1 2 3 4 5 ; do
      trace "Waiting $name (pid $pid) to die..."
      status || break
      sleep 1
    done
    if status ; then
      if [ "$KILL_ON_STOP_TIMEOUT" -eq 1 ] ; then
        trace "Timeout reached. Killing $name (pid $pid) with SIGKILL.  This may result in data loss."
        kill -KILL $pid
        emit "$name killed with SIGKILL."
      else
        emit "$name stop failed; still running."
      fi
    else
      emit "$name stopped."
    fi
  fi
}

status() {
  if [ -f "$pidfile" ] ; then
    pid=$(cat "$pidfile")
    if ps -p $pid > /dev/null 2> /dev/null ; then
      # process by this pid is running.
      # It may not be our pid, but that's what you get with just pidfiles.
      # TODO(sissel): Check if this process seems to be the same as the one we
      # expect. It'd be nice to use flock here, but flock uses fork, not exec,
      # so it makes it quite awkward to use in this case.
      return 0
    else
      return 2 # program is dead but pid file exists
    fi
  else
    return 3 # program is not running
  fi
}

force_stop() {
  if status ; then
    stop
    status && kill -KILL $(cat "$pidfile")
  fi
}

{{- if .prestart }}
prestart() {
  {{ .prestart }}

  status=$?

  if [ $status -gt 0 ] ; then
    emit "Prestart command failed with code $status. If you wish to skip the prestart command, set PRESTART=no in your environment."
  fi
  return $status
}
{{ end }}

case "$1" in
  force-start|start|stop|force-stop|restart)
    trace "Attempting '$1' on {{ .app }}-{{ .process_type }}-{{ .num }}"
    ;;
esac

case "$1" in
  force-start)
    PRESTART=no
    exec "$0" start
    ;;
  start)
    status
    code=$?
    if [ $code -eq 0 ]; then
      emit "$name is already running"
      exit $code
    else
      start
      exit $?
    fi
    ;;
  stop) stop ;;
  force-stop) force_stop ;;
  status)
    status
    code=$?
    if [ $code -eq 0 ] ; then
      emit "$name is running"
    else
      emit "$name is not running"
    fi
    exit $code
    ;;
  restart)
    {{- if .prestart}}if [ "$PRESTART" != "no" ] ; then
      prestart || exit $?
    fi{{ end }}
    stop && start
    ;;
  *)
    echo "Usage: $SCRIPTNAME {start|force-start|stop|force-start|force-stop|status|restart}" >&2
    exit 3
  ;;
esac

exit $?
